



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="myHikari" href="http://myhikari.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="myHikari" href="http://myhikari.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="myHikari" href="http://myhikari.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="Redis" />


<link rel="canonical" href="http://myhikari.github.io/2023/09/15/Redis/">



  <title>
Redis - Redis |
Yume Shoka = myHikari = myHikari</title>
<meta name="generator" content="Hexo 7.2.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Redis
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-09-15 17:51:32">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-09-15T17:51:32+08:00">2023-09-15</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Yume Shoka</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipetv6p75j20zk0m8x6p.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giph4lm9i7j20zk0m84qp.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipevarprfj20zk0m8npd.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclip4jbpj20zk0m87cv.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Redis/" itemprop="item" rel="index" title="分类于 Redis"><span itemprop="name">Redis</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://myhikari.github.io/2023/09/15/Redis/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="myHikari">
    <meta itemprop="description" content="myHikari, myHikari 个人博客">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="myHikari">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis-介绍"><a href="#Redis-介绍" class="headerlink" title="Redis 介绍"></a>Redis 介绍</h2><h3 id="NoSQL-介绍"><a href="#NoSQL-介绍" class="headerlink" title="NoSQL 介绍"></a>NoSQL 介绍</h3><p>NoSQL(Not Only SQL)，意即“不仅仅是 SQL”，泛指非关系型的数据库。</p>
<p>NoSQL 不依赖业务逻辑方式存储，而以简单的 key-value 模式存储。因此大大的增加了数据库的扩展能力。</p>
<p>在对数据高并发、海量数据的读写的场景下有很高的性能。但是它不遵循 sql 标准，也不支持 ACID。</p>
<h4 id="解决-CPU-及内存压力"><a href="#解决-CPU-及内存压力" class="headerlink" title="解决 CPU 及内存压力"></a>解决 CPU 及内存压力</h4><p><img src="/images/redis-resolveMemoryStress.png" alt="image-20210708204923132"></p>
<p>在进行负载均衡的时候，如何让每台服务器都能知道用户的状态？</p>
<ol>
<li>存在 cookie 里<ul>
<li>保存在客户端，不安全</li>
</ul>
</li>
<li>每台服务器都复制一份 session<ul>
<li>session 数据冗余，节点越多浪费越大</li>
</ul>
</li>
<li>保存在缓存数据库中<ul>
<li>数据在内存中，速度快，存储结构简单</li>
</ul>
</li>
</ol>
<h4 id="解决数据库的-IO-压力"><a href="#解决数据库的-IO-压力" class="headerlink" title="解决数据库的 IO 压力"></a>解决数据库的 IO 压力</h4><p>在数据量很大的时候，可以把经常用到的查询的数据放到缓存数据库中，减少对数据库的 IO 读操作。</p>
<h3 id="Redis-介绍-1"><a href="#Redis-介绍-1" class="headerlink" title="Redis 介绍"></a>Redis 介绍</h3><p>Redis 是一个开源的 key-value 存储系统。它支持存储的 value 类型相对更多，包括 string(字符串)、list(链表)、set(集合)、zset(有序集合) 和 hash(哈希类型)。</p>
<p>这些数据类型支持 push&#x2F;pop、add&#x2F;remove 及取交集、并集和差集等操作，而且这些操作都是<strong>原子性</strong>的。在此基础上，Redis 支持各种不同方式的排序。为了保证效率，数据都在内存中进行操作，然后会<strong>周期性</strong>的把更新的数据写入磁盘或者把修改操作追加写入到记录文件。并且在此基础上实现了 master-slave**(主从)同步**。</p>
<blockquote>
<p>Redis 是单线程+多路 IO 复用技术。而 memcached 使用的是多线程+锁。</p>
</blockquote>
<p><strong>多路复用</strong>是指&#x3D;&#x3D;一个线程&#x3D;&#x3D;可以检查&#x3D;&#x3D;多个文件描述符（Socket）&#x3D;&#x3D;的就绪状态（一般是读就绪或者写就绪），一旦某个描述符就绪，能够通知程序进行相应的读写操作。</p>
<p>多路复用的优势并不是在于单个连接能处理的更快，而是单个线程&#x2F;进程可以处理更多的连接。系统不必创建多个进程&#x2F;线程，从而大大减小了系统的开销。</p>
<hr>
<p>应用场景</p>
<ol>
<li>配合关系型数据库做高速缓存，降低数据库 IO</li>
<li>分布式架构中，做 session 共享</li>
<li>使用结构存储持久化数据</li>
</ol>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>关于数据库的一些操作：</p>
<ul>
<li>select dbid：命令切换数据库。redis 默认有 16 个数据库，类似数组下标从 0 开始，初始默认使用 0 号库<ul>
<li><code>select 8</code> 使用 8 号数据库</li>
</ul>
</li>
<li>dbsize：查看当前数据库的 key 的数量</li>
<li>flushdb：清空当前库</li>
<li>flushall：清空全部库</li>
</ul>
<hr>
<p>关于 key 的一些操作：</p>
<ul>
<li>keys pattern：查找所有符合给定模式 pattern，相当于正则<ul>
<li><code>keys *</code> 匹配数据库中所有 key。</li>
<li><code>keys h[ae]llo</code> 匹配 hallo 或 hello 的 key</li>
</ul>
</li>
<li>exists key：判断某个 key 是否存在。存在返回 1，否则返回 0</li>
<li>type key：查看 key 是什么类型</li>
<li>del key：删除指定的 key 的数据</li>
<li>unlink key：非阻塞方式删除指定的 key 的数据。先将 key 从 keyspace 元数据中删除，真正的删除在后续的异步操作。</li>
<li>expire key t：为给定的 key 设置过期时间，单位为秒</li>
<li>ttl key：查看还有多少秒过期。**-1 表示永不过期，-2 表示已过期**</li>
</ul>
<h3 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h3><h4 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h4><p>string 类型是以二进制存储的。意味着 Redis 的 string 可以包含任何数据，比如 jpg 图片或者序列化的对象。</p>
<p>string 的数据结构：</p>
<ul>
<li>如果是数字，则直接使用 int。</li>
<li>否则，使用<strong>简单动态字符串</strong>，内部结构的实现类似于 Java 的 ArrayList，采用 预分配冗余空间 的方式来减少内存的频繁分配。</li>
</ul>
<p>当字符串长度小于 1M 时，扩容的大小是原来的一倍；如果超过 1M，每次扩容只会多扩大 1M 的空间。&#x3D;&#x3D;需要注意的是字符串最大长度为 512M&#x3D;&#x3D;。</p>
<ul>
<li><code>set k v [nx] [px t]</code>：添加键值对，会替换之前的值。nx 表示 key 不存在才会 set，px t 表示过期时间。</li>
<li><code>mset k1 v1 k2 v2 k3 v3 .....</code>：同时设置一个或多个 key-value 对</li>
<li><code>get k</code>：根据 k 查询 value</li>
<li><code>mget k1 k2 k3 .....</code>：同时获取一个或多个 k 的 v</li>
<li><code>setnx  k v</code>：只有在 k 不存在时，才会添加成功。等同于<code>set k v nx</code></li>
<li><code>msetnx k1 v1 k2 v2 k3 v3 .....</code>：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<ul>
<li>原子操作，有一个失败则都失败。</li>
</ul>
</li>
<li><code>append k v</code>：追加 v 到原值的末尾</li>
<li><code>strlen k</code>：获得值的长度</li>
<li><code>incr k</code>：将 k 中储存的<strong>数字值</strong>加 1。只能对数字值操作，否则报错。</li>
<li><code>decr k</code>：将 k 中储存的<strong>数字值</strong>减 1</li>
<li><code>incrby/decrby k 步长</code>：将 k 中储存的数字值根据步长进行增&#x2F;减。</li>
<li><code>getrange k s e</code>：获得值的范围，<strong>左闭右闭</strong>。</li>
<li><code>setrange k s v</code>：用 v 覆写 k 所储存的从 s 开始的字符串值。</li>
</ul>
<p>应用场景：</p>
<ol>
<li>存储单键</li>
<li><strong>分布式锁</strong></li>
</ol>
<h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h4><p>特点：单键多值</p>
<p>Redis 列表是简单的<strong>字符串列表</strong>。你可以在列表的头部（左边）或者尾部（右边）添加一个元素。</p>
<p>它的底层类似于双向链表，对两端的操作性能很高，通过索引下标操作中间的节点性能会较差。</p>
<p>首先在列表元素较少的情况下它会将所有的元素紧挨着一起存储，使用一块连续的内存空间，这个结构是<code>ziplist</code>，即是<strong>压缩列表</strong>。</p>
<p><img src="/images/redis-list.png" alt="image-20210801102417952"></p>
<ul>
<li><strong>zlbytes</strong>表示这个 ziplist 占用的大小</li>
<li><strong>zltail</strong>表示最后一个元素的偏移量，可以很快速的从后往前找。</li>
<li><strong>zllen</strong>表示元素个数。</li>
<li><strong>entry</strong>表示元素</li>
<li><strong>zlend</strong>标记 ziplist 的结尾</li>
</ul>
<p>当数据量比较多的时候会改成<code>quicklist</code>，如下图所示：</p>
<p><img src="/images/redis-list1.png" alt="image-20210708225035910"></p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。</p>
<ul>
<li><code>lpush/rpush k v1 v2 v3 …</code>：从左边&#x2F;右边插入一个或多个值。</li>
<li><code>lpop/rpop k</code>：从左边&#x2F;右边吐出一个值。如果所有的值都被 pop 掉，则 k 也会消失。</li>
<li><code>rpoplpush k1 k2</code>：从 k1 列表右边吐出一个值，插到 k2 列表左边。</li>
<li><code>lrange k s e</code>：获得下标为**[s, e]**元素（左闭右闭）<ul>
<li>若 e 为负数，表示从右边开始取，此时下标从 1 开始。</li>
<li><code>lrange k1 0 -1</code> 取出左边第一个到右边第一个的元素</li>
</ul>
</li>
<li><code>lindex k index</code>：获取下标为 index 的元素(从左到右)</li>
<li><code>llen k</code>：获得列表长度</li>
<li><code>linsert k before/after v1 v2</code>：在 v1 的前面&#x2F;后面插入 v2</li>
<li><code>lrem k n v</code>：从左边第一个元素开始，删除 n 个 v</li>
<li><code>lset k index v</code>：将列表 k 下标为 index 的值替换成 v</li>
</ul>
<hr>
<p>应用场景：</p>
<ol>
<li>推送消息</li>
<li>关注列表</li>
</ol>
<h4 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h4><p>set 是 string 类型的集合，具有自动排序去重功能，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 可以判断某个成员是否在该 set 里，这个是 list 所不能提供的。</p>
<blockquote>
<p>set 的数据结构：</p>
<ul>
<li><p>如果是数字，则使用数组，查找的时候二分查找，但插入的复杂度是 O(N)</p>
</li>
<li><p>否则使用一个 value 为 null 的 hash 表，此时添加，删除，查找的复杂度都是 O(1)</p>
</li>
</ul>
</blockquote>
<ul>
<li><code>sadd k v1 v2 .....</code>：将一个或多个元素加入到集合 key 中，已经存在的元素将被忽略</li>
<li><code>smembers k</code>：取出该集合的所有值。</li>
<li><code>sismember k v</code>：判断 k 集合中是否含有 v 值；有则返回 1，没有则返回 0。</li>
<li><code>scard k</code>：返回该集合的元素个数。</li>
<li><code>srem k v1 v2 ....</code>：删除 k 集合中的元素。</li>
<li><code>spop k</code>：<strong>随机</strong>从该集合中吐出一个值。</li>
<li><code>smove src dst value</code>：把集合 src 中一个值移动到集合 dst 中</li>
<li><code>sinter k1 k2</code>：返回两个集合的<strong>交集</strong>元素。</li>
<li><code>sunion k1 k2</code>：返回两个集合的<strong>并集</strong>元素。</li>
<li><code>sdiff k1 k2</code>：返回两个集合的<strong>差集</strong>元素。(k1 中存在的，不包含 k2 的)</li>
</ul>
<hr>
<p>应用场景：</p>
<ol>
<li>抽奖活动</li>
<li>共同关注</li>
</ol>
<h4 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 hash"></a>哈希 hash</h4><p>hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于<strong>存储对象</strong>，类似 Java 里面的 Map&lt;String,Object&gt;。</p>
<p>hash 类型对应的数据结构是两种：<strong>ziplist，hashtable</strong>。当 field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable。</p>
<ul>
<li><code>hset k field1 value1 field2 value2 ... </code>：批量设置 field-value<ul>
<li>k 通常表示一个对象，可以结合 id 使用，如<code>hset user:12 name hjh age 10</code></li>
</ul>
</li>
<li><code>hget k field</code>：从哈希表 k 的 field 取出 value</li>
<li><code>hexists k field</code>：查看哈希表 k 中，给定域 field 是否存在。</li>
<li><code>hkeys k</code>：列出该哈希表的所有 field</li>
<li><code>hvals k</code>：列出该哈希表的所有 value</li>
<li><code>hincrby k field increment</code>：为哈希表 k 中的 field 的 value 加上 increment</li>
<li><code>hsetnx k field value</code>：当 field 不存在时，设置哈希表 k 中的 field-value</li>
</ul>
<hr>
<p>应用场景：</p>
<ol>
<li>存放对象</li>
<li>购物车</li>
<li>收藏</li>
</ol>
<h4 id="有序集合-zset"><a href="#有序集合-zset" class="headerlink" title="有序集合 zset"></a>有序集合 zset</h4><p>有序集合 zset 与普通集合 set 非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员 member 都关联了一个评分 score, zset 按照 score 进行排序（score 可以重复） 。因为元素是有序的，所以你也可以很快的根据评分 score 或者排名 range 来获取一个范围的元素。</p>
<p>zset 类似于 TreeMap，内部成员 member 会按照评分 score 进行排序。因此可以得到每个 member 的名次，还可以通过 score 的范围来获取 member。</p>
<ul>
<li><code>zadd k score1 mem1 score2 mem2 …</code>：将一个或多个 member 元素及其 score 值加入到有序集 k 当中。</li>
<li><code>zrange k s e [WITHSCORES]</code>：返回有序集 k 中，<strong>排名</strong>在[s, e]之间的 member。带 WITHSCORES，则分数一起返回。</li>
<li><code>zrangebyscore k min max [withscores] [limit offset count]</code>：返回有序集 k 中，所有 score 值介于 [min, max] 的成员。有序集成员按 <strong>score</strong> 值递增。<ul>
<li>可通过<code>(</code>指定开区间：<code>zrangebyscore k (1 5</code> 返回 k 中的 1 &lt; score &lt;&#x3D; 5 的成员</li>
</ul>
</li>
<li><code>zrevrangebyscore key maxmin [withscores] [limit offset count]</code>：同上，改为从大到小排列。</li>
<li><code>zincrby k n member</code>：为 member 的 score 加上 n</li>
<li><code>zrem k member</code>：删除该集合的 member</li>
<li><code>zcount k min max</code>：统计该集合，[min, max]区间内的元素个数</li>
<li><code>zrank k member</code>：返回 member 在集合中的排名，从 0 开始</li>
</ul>
<p>应用场景：</p>
<ol>
<li>点赞</li>
<li>排行榜</li>
</ol>
<hr>
<p>zset 底层使用了两个数据结构</p>
<ol>
<li><p>ziplist：第一个节点保存 member，第二个节点保存 score。ziplist 内的集合元素按 score 从小到大排序。</p>
<p><img src="/images/redis-zset.png" alt="image-20210709093008848"></p>
</li>
<li><p>skiplist：在 member 个数大于等于 128 时，使用 skiplist 存储数据。由 hash 表跟跳跃表实现。</p>
<ul>
<li>跳表的每个节点包含了 层高、score、指针（指向 member 在 hashtable 中地址）</li>
<li>跳表按 score 从小到大保存所有集合元素</li>
</ul>
</li>
</ol>
<p>跳跃表结构：</p>
<p><img src="/images/redis-skip-zset.png" alt="image-20210709093803448"></p>
<ul>
<li>每个节点的层高都是随机的</li>
<li>查询的时间复杂度为 O(logn)</li>
<li>插入，删除时间复杂度均为 O(logn)，最坏情况下时间复杂度为 O(n)</li>
<li>插入节点时需要记录每一层是从哪个节点下来的，方便新元素更新层高</li>
</ul>
<h3 id="新数据类型"><a href="#新数据类型" class="headerlink" title="新数据类型"></a>新数据类型</h3><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h4><p>Bitmaps 这个“数据类型”可以实现对于 <strong>位</strong> 的操作：</p>
<p>Bitmaps 本身不是一种数据类型， 实际上它就是字符串，它可以对字符串的位进行操作。</p>
<p>可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做<strong>偏移量</strong>。</p>
<p><img src="/images/redis-bitmaps.png" alt="image-20210709165605401"></p>
<p>Bitmaps 常用于<strong>信息状态的统计</strong>，比如用户每天签到的记录，用户访问量等。</p>
<ul>
<li><p><code>setbit key offset value</code>：将 offset 的位置设为 value</p>
<ul>
<li><code>setbit users 9 1</code></li>
<li>在第一次初始化 Bitmaps 时，如果偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成 Redis 阻塞。默认值为 0</li>
</ul>
</li>
<li><p><code>getbit key offset</code>：获取 offset 位置的值</p>
<ul>
<li><code>getbit user 9</code></li>
</ul>
</li>
<li><p><code>bitcount key [start] [end]</code>：计算指定范围内的 offset 位置值的和。</p>
<p>【注意】start 跟 end 表示的是下标，并不是位。</p>
<p>offset【01000001 01000000 00000000 00100001】对应下标【0，1，2，3】</p>
<p><code>bitcount k 0 1</code>：计算的是 01000001 01000000，返回 3</p>
</li>
<li><p><code>bitop and(or/not/xor) destKey key1 [key2...]</code>：对指定 key 按位进行交、并、非、异或操作并将结果保存在 destkey 中。</p>
<ul>
<li><p>比如 2020-11-03 日访问网站的 userid&#x3D;0,1,4,9。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">setbit users:<span class="hljs-number">20201103</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br>setbit users:<span class="hljs-number">20201103</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br>setbit users:<span class="hljs-number">20201103</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br>setbit users:<span class="hljs-number">20201103</span> <span class="hljs-number">9</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>2020-11-04 日访问网站的 userid&#x3D;1,2,5,9。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">setbit users:<span class="hljs-number">20201104</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br>setbit users:<span class="hljs-number">20201104</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>setbit users:<span class="hljs-number">20201104</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br>setbit users:<span class="hljs-number">20201104</span> <span class="hljs-number">9</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>然后计算出两天都访问过网站的用户数量</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">bitop and users:<span class="hljs-number">0403</span> users:<span class="hljs-number">20201103</span> users:<span class="hljs-number">20201104</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<p>Bitmaps 与 set 对比</p>
<p>假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表：</p>
<p><img src="/images/redis-bitmaps-set.png" alt="image-20210709172052851"></p>
<p>可以看出 bitmaps 所占用的内存小很多。但 bitmaps 需要把每个用户都存储下来。所以当该网站每天访问的用户很少时，Bitmaps 就有点不合时宜了</p>
<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>HyperLogLog 是用来做基数统计的算法，其优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。需要注意的是，这里计算的基数是有误差的，不过误差在可以接受的范围内。</p>
<blockquote>
<p>何为基数？</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为 5。</p>
</blockquote>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而<strong>不会储存输入元素本身</strong>，所以 HyperLogLog 不能像集合那样返回输入的各个元素。</p>
<ul>
<li><code>pfadd key element1 [element2 ...]</code>：添加数据</li>
<li><code>pfcount key1 [key2 ...]</code>：统计基数</li>
<li><code>pfmerge destkey key1 [key2 ...]</code>：将多个 HyperLogLog 的基数合并到 destkey 中</li>
</ul>
<p><img src="/images/redis-hyperLog.png" alt="image-20210709174405306"></p>
<p><img src="/images/redis-hyperlog1.png" alt="image-20210709174411766"></p>
<h4 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h4><p>Redis 3.2 中增加了对 GEO 类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的 2 维坐标，在地图上就是经纬度。redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。</p>
<ul>
<li><code>geoadd key 经度1 纬度1 member1 [经度2 纬度2 member2 ...]</code>：设置元素的坐标点</li>
<li><code>geopos key member1 [member2 ...]</code>：获取元素的坐标点</li>
<li><code>geodist key member1 member2 [m|km|ft|mi]</code>：计算坐标点的直线距离。可指定单位：m 米（默认值）、km 千米 、mi 英里 、ft 英尺。</li>
<li><code>georadius key 经度 纬度 r m|km|ft|mi [withcoord] [withdist] [count count]</code>：以给定的经纬度为中心，找出 半径 r 内的元素。</li>
</ul>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p style="text-align:center;">Units</p>

<ol>
<li>配置大小单位，开头定义了一些基本的度量单位，只支持 bytes，不支持 bit</li>
<li>大小写不敏感</li>
</ol>
<p><img src="/images/redis-conf-units.png" alt="image-20210709221458712"></p>
<p style="text-align:center;">INCLUDE</p>

<p>导入配置文件，类似于 spring 的 import、jsp 中的 include。</p>
<p><img src="/images/redis-conf-include.png" alt="image-20210709221823280"></p>
<p style="text-align:center;">NETWORK</p>

<p>网络相关配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> = 127.0.0.1 <span class="hljs-comment"># 默认只接收本机的访问请求</span><br>protected-mode <span class="hljs-built_in">yes</span> <span class="hljs-comment"># 保护模式，默认开启</span><br>port 6379 <span class="hljs-comment"># 端口号</span><br><span class="hljs-built_in">timeout</span> 0 <span class="hljs-comment"># 一个空闲的客户端维持多少秒会关闭，0表示关闭该功能，即不关闭客户端</span><br>tcp-keepalive 300 <span class="hljs-comment"># 每隔n秒检测一次客户端是否还活跃</span><br></code></pre></td></tr></table></figure>

<p style="text-align:center;">GENERAL</p>

<p>通用设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">daemonize <span class="hljs-built_in">yes</span> <span class="hljs-comment"># 是否是守护线程，即后台启动。默认为no</span><br>pidfile /var/run/redis_6379.pid <span class="hljs-comment"># 若以后台运行则需要指定一个pid文件</span><br>loglevel notice <span class="hljs-comment"># 日志级别</span><br><span class="hljs-comment"># 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice</span><br>databases 16 <span class="hljs-comment"># 数据库的数量</span><br></code></pre></td></tr></table></figure>

<p style="text-align:center;">SNAPSHOTTING</p>

<p>快照相关设置：通常进行持久化设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">save 900 1 <span class="hljs-comment"># 900s内，如果至少一个key进行了修改，则进行持久化操作</span><br>save 300 10 <span class="hljs-comment"># 300s内，如果至少十个key进行了修改，则进行持久化操作</span><br>save 60 10000 <span class="hljs-comment"># 60s内，如果至少10000个key进行了修改，则进行持久化操作</span><br>stop-write-no-bgsave-error <span class="hljs-built_in">yes</span> <span class="hljs-comment"># 持久化操作失败，是否继续工作</span><br>rdbchecksum <span class="hljs-built_in">yes</span> <span class="hljs-comment"># 在存储快照后，进行数据校验，但是这样做会增加大约10%的性能消耗</span><br>rdbcompression <span class="hljs-built_in">yes</span> <span class="hljs-comment"># 是否压缩rdb文件</span><br>dbfilename dump.rdb <span class="hljs-comment"># rbd默认的文件名</span><br><span class="hljs-built_in">dir</span> ./ <span class="hljs-comment"># rdb文件保存的目录</span><br></code></pre></td></tr></table></figure>

<p style="text-align:center;">SECURITY</p>

<p>安全设置</p>
<p>设置密码</p>
<ol>
<li><p>手动修改配置文件：添加<code>requirepass 密码</code></p>
<p><img src="/images/redis-conf-security.png" alt="image-20210709225421211"></p>
</li>
<li><p>命令的方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">config <span class="hljs-built_in">set</span> requirepass 123456<br>config rewrite <span class="hljs-comment"># 写入配置文件中，不然重启就没了</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>当需要输入密码的时候：<code>auth 密码</code></p>
<p><img src="/images/redis-conf-security1.png" alt="image-20210709225710831"></p>
<p style="text-align:center;">LIMIT</p>

<p>限制设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">maxclients 10000 <span class="hljs-comment"># 设置redis同时可以与多少个客户端进行连接</span><br>maxmemory &lt;bytes&gt; <span class="hljs-comment"># 设置redis可以使用的最大内存量</span><br>maxmemory-policy noeviction <span class="hljs-comment"># 内存满了之后执行淘汰策略</span><br></code></pre></td></tr></table></figure>

<p>在 redis 中，允许用户设置的最大使用内存大小：64 位的电脑默认无限制，32 位的电脑默认不超过 3G。</p>
<blockquote>
<p>哪个命令可以查看内存情况？<code>info memory</code></p>
</blockquote>
<h3 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h3><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。客户端可以订阅任意数量的频道。</p>
<p><img src="/images/redis-pubsub-sub.png" alt="发布订阅"></p>
<p><img src="/images/redis-pubsub-pub.png" alt="发布订阅"></p>
<p>相关命令：</p>
<ul>
<li><code>subscribe channel</code>：订阅一个或者多个频道；</li>
<li><code>unsubscribe channel</code>：退订一个或者多个频道；</li>
<li><code>publish channel mes</code>：向通道发送消息；</li>
</ul>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis 提供 2 个不同形式的持久化方式。</p>
<ul>
<li>RDB（Redis DataBase）：根据配置的规则定时将内存中的数据持久化到硬盘上。</li>
<li>AOF（Append Of File）：在每次执行<strong>写</strong>命令之后将命令记录到文件。</li>
</ul>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>在指定的<strong>时间间隔内</strong>将内存中的数据写入磁盘生成一个副本，该过程称作”快照”。 Redis 启动时会自动读取 RDB 快照文件。</p>
<p>Redis 默认会将快照文件存储在 Redis 当前进程的工作目录的 dump.rdb 文件中，可以通过配置文件中的 <code>dir</code> 和 <code>dbfilename</code> 两个参数分别指定快照文件的 存储路径 和 文件名。</p>
<p>优点：</p>
<ol>
<li>适合大规模的数据恢复</li>
<li>节省磁盘空间</li>
<li>最大化 redis 性能，因为父进程只需要 fork 子进程去保存文件</li>
</ol>
<p>缺点：</p>
<ol>
<li>内存中的数据被克隆一份，需要 2 倍的内存</li>
<li>存在数据丢失的情况</li>
</ol>
<h5 id="快照执行的过程"><a href="#快照执行的过程" class="headerlink" title="快照执行的过程"></a>快照执行的过程</h5><ol>
<li>Redis 使用 fork 函数复制一份当前进程（父进程）的副本（子进程）；</li>
<li>父进程继续处理来自客户端的请求，子进程开始将内存中的数据写入硬盘中的临时文件；</li>
<li>当子进程写完所有的数据后，用该临时文件替换旧的 RDB 文件，至此，一次快照操作完成。</li>
</ol>
<blockquote>
<p>fork 创建的新进程被称为子进程，拥有父进程数据空间、堆、栈等资源的副本。由于 RDB 文件存储的是执行 fork 操作那一刻的内存数据，而 fork 之后修改的数据不会写进 RDB 文件，所以 RDB 方式存在数据丢失的情况。</p>
</blockquote>
<h5 id="执行快照的场景"><a href="#执行快照的场景" class="headerlink" title="执行快照的场景"></a>执行快照的场景</h5><ol>
<li>根据配置自动快照</li>
<li>执行 SAVE 或 BGSAVE 命令<ul>
<li>当我们需要重启，迁移，备份 Redis 时，我们也可以手动执行 SAVE 或 BGSAVE 命令主动进行快照操作</li>
<li><strong>SAVE 命令</strong>：当执行 SAVE 命令时，Redis 同步进行快照操作，期间会阻塞所有来自客户端的请求，所以在写入数据较多时，应该避免使用该命令；</li>
<li><strong>BGSAVE 命令</strong>： 该命令的快照操作是在后台异步进行的，进行快照操作的同时还能处理来自客户端的请求。</li>
</ul>
</li>
<li>执行 FLUSHALL 命令</li>
<li>执行复制</li>
</ol>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>在使用 Redis 存储非临时数据时，一般都需要打开 AOF 持久化来降低数据丢失，AOF 可以将 Redis 执行的每一条<strong>写</strong>命令追加到硬盘文件中。redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p>默认情况下，Redis 没有开启 AOF（append only file）持久化功能，需要通过在配置文件中修改配置：<code>appendonly yes</code></p>
<p>AOF 文件保存路径和 RDB 文件路径是一致的，都是通过 dir 参数配置，默认文件名是：<code>appendonly.aof</code>，可以通过配置 appendonlyfilename 参数修改，如<code>appendonlyfilename appendonly.aof </code></p>
<blockquote>
<p>⚠️ 注意：AOF 和 RDB 同时开启，系统默认取 <strong>AOF</strong> 的数据。</p>
</blockquote>
<h5 id="AOF-持久化流程"><a href="#AOF-持久化流程" class="headerlink" title="AOF 持久化流程"></a>AOF 持久化流程</h5><ol>
<li>客户端的请求<strong>写</strong>命令会被 append 追加到 AOF 缓冲区内；</li>
<li>AOF 缓冲区根据 AOF 持久化策略[always, everysec, no] 将操作同步到磁盘的 AOF 文件中；</li>
<li>AOF 文件大小超过重写策略或手动重写时，会对 AOF 文件 rewrite 重写，压缩 AOF 文件容量；</li>
<li>Redis 服务重启时，会重新加载 AOF 文件中的写操作达到数据恢复的目的；</li>
</ol>
<h5 id="AOF-持久化策略"><a href="#AOF-持久化策略" class="headerlink" title="AOF 持久化策略"></a>AOF 持久化策略</h5><p>AOF 持久化策略（同步机制）需要在配置文件中进行设置：<code>appendfsync everysec</code></p>
<ul>
<li>always：始终同步，每次 Redis 的写入都会立刻记入日志；性能较差但数据完整性比较好。</li>
<li>everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</li>
<li>no：redis 不主动进行同步，把同步时机交给操作系统。对大多数 Linux 操作系统，是每 30 秒进行一次 fsync，将缓冲区中的数据写到磁盘上。</li>
</ul>
<h5 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h5><p>AOF 采用文件追加方式，文件会越来越大。为避免出现此种情况，新增了重写机制，当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩， 只保留可以恢复数据的最小指令集。比如前面两个命令会被第三个命令覆盖，所以 AOF 文件只会保留第三个命令。或者两个命令可以合成一个命令。</p>
<p>什么时候会重写？</p>
<p>AOF 大小超过阈值，并且与上一次重写后的大小的比值达到百分比 时触发重写。</p>
<p><strong>tips</strong>：redis 会记录上一次重写后的大小。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">auto-aof-rewrite-percentage <span class="hljs-number">100</span> # 百分比<br>auto-aof-rewrite-min-size <span class="hljs-number">64</span>mb # 阈值<br></code></pre></td></tr></table></figure>

<ul>
<li><input checked="" disabled="" type="checkbox"> 文件达到 70MB 开始重写，降到 50MB，下次什么时候开始重写？100MB</li>
</ul>
<hr>
<p>重写原理：</p>
<ol>
<li>Redis 调用 fork 创建子进程执行重写操作，父进程继续处理客户端请求。</li>
<li>父进程将写命令追加 AOF 缓冲区中，同时缓存到重写空间中。这样可以保证子进程如果重写失败，原文件不会出现问题。</li>
<li>当子进程完成对新 AOF 文件重写之后通知父进程，父进程就将重写空间中的命令写入到新 AOF 文件中。</li>
<li>父进程将新 AOF 文件替换旧的 AOF 文件并重命名，后续的命令追加到新的 AOF 文件中。</li>
</ol>
<h5 id="文件损坏恢复"><a href="#文件损坏恢复" class="headerlink" title="文件损坏恢复"></a>文件损坏恢复</h5><p>遇到 AOF 文件损坏，通过 redis 目录下的<code>redis-check-aof</code> 的工具，使用命令<code>redis-check-aof --fix 文件名称</code> 进行修复。需要重启 redis。</p>
<h4 id="用哪个好"><a href="#用哪个好" class="headerlink" title="用哪个好"></a>用哪个好</h4><p>官方推荐两个都启用。</p>
<p>如果只是做纯内存缓存，可以都不用。</p>
<p>如果对数据不敏感，可以选单独用 RDB。</p>
<p>不建议单独用 AOF，因为可能会出现 Bug。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主机 master 数据更新后根据配置和策略自动同步到从机 slave，<strong>Master</strong>以<strong>写</strong>为主，<strong>Slave</strong>以<strong>读</strong>为主。</p>
<p>主从刚刚连接的时候，进行全量同步；全量同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
<p>好处：</p>
<ol>
<li>读写分离，性能扩展</li>
<li>可以对数据进行备份。</li>
<li>容灾快速恢复：一个从机挂了，可以很快速的恢复到与主机同步的数据。</li>
</ol>
<p><img src="/images/reids-master-slave-copy.png" alt="image-20210710192938290"></p>
<h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4><ol>
<li>Slave 启动成功连接到 master 后会发送一个 sync 命令</li>
<li>Master 接到命令开始执行 BGSAVE 命令生成 RDB 文件 并 使用缓冲区记录此后执行的所有写命令，BGSAVE 命令执行完之后，master 将快照文件传送到 slave。slave 服务在接收到数据库文件后，将其存盘并加载到内存中。此过程称为<strong>全量同步</strong>。</li>
<li><strong>增量同步</strong>：全量同步之后，Master 将新的所有收集到的修改命令依次传给 slave，完成增量同步。</li>
<li>如果有 slave 断线，重启之后不会自动连上 matser，此时自己为 master。手动变成从机之后，会发送 sync 请求和主机全量同步。</li>
</ol>
<p>从机也可以有自己的从机，但自己断线之后，自己的从机们都无法接收到主机的数据。假设从机 2 归属于从机 1，此时如果从机 1 断线了，那么从机 2 将无法获取到主机的数据。</p>
<p><img src="/images/redis-master-slave-copy1.jpg" alt="preview"></p>
<h4 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Q</span>：从机可以进行写操作？<br><span class="hljs-selector-tag">A</span>：一般不可以。但可以通过配置文件让从服务器然后支持写操作。<br></code></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">Q：主机<span class="hljs-keyword">shutdown</span>后情况如何？从机是上位还是原地待命？<br>A：主机<span class="hljs-keyword">shutdown</span>后，从机不会做任何事情，当主机重新连接之后一切照常。在主机断线的时候，从机可以使用slaveof <span class="hljs-keyword">no</span> one命令成为主机。<br></code></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Q：主机会将数据保存在rdb文件中然后发送给<span class="hljs-literal">slave</span>服务器，但是如果主机上的磁盘空间有限怎么办呢？<br>A：<span class="hljs-literal">master</span>直接开启一个socket将rdb文件发送给<span class="hljs-literal">slave</span>服务器。<br></code></pre></td></tr></table></figure>

<h4 id="搭建主从复制"><a href="#搭建主从复制" class="headerlink" title="搭建主从复制"></a>搭建主从复制</h4><ol>
<li><p>Appendonly 关掉或者在每个配置文件中修改 appendfilename</p>
</li>
<li><p>新建多个配置文件（每个配置文件相当于一台机器），每次文件编写以下配置。</p>
<p>如 redis6379.conf</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">include /myredis/redis.conf # 固定<br>pidfile /var/run/redis_6379.pid # redis_XXX修改成跟配置文件名一样<br>port <span class="hljs-number">6379</span> # 每个配置文件的端口号<br>dbfilename dump6379.rdb  # dumpXXX.rdb修改成跟配置文件名一样<br></code></pre></td></tr></table></figure>

<p>redis6380.conf</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">include /myredis/redis.conf # 固定<br>pidfile /var/run/redis_6380.pid # redis_XXX修改成跟配置文件名一样<br>port <span class="hljs-number">6380</span> # 每个配置文件的端口号<br>dbfilename dump6380.rdb  # dumpXXX.rdb修改成跟配置文件名一样<br></code></pre></td></tr></table></figure>

<p>redis6381.conf</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">include /myredis/redis.conf # 固定<br>pidfile /var/run/redis_6381.pid # redis_XXX修改成跟配置文件名一样<br>port <span class="hljs-number">6381</span> # 每个配置文件的端口号<br>dbfilename dump6381.rdb  # dumpXXX.rdb修改成跟配置文件名一样<br></code></pre></td></tr></table></figure>
</li>
<li><p>启动三台 redis 服务器</p>
<p><img src="/images/redis-master-slave-copy2.png" alt="image-20210710203241308"></p>
<p>可以使用<code>info replication</code>命令打印主从复制的相关信息</p>
</li>
<li><p>配置从机：<code>slaveof ip port</code></p>
<p>在 6380 和 6381 上执行: <code>slaveof 127.0.0.1 6379</code> 此时这两台主机变成 6379 的从机</p>
</li>
<li><p>搭建完成。</p>
</li>
</ol>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>Redis 主从复制的作用有数据热备、负载均衡、故障恢复等；但<strong>主从复制存在的一个问题是故障恢复无法自动化</strong>。</p>
<p>哨兵（sentinel）是基于 Redis 主从复制，<strong>解决主机故障恢复的自动化问题</strong>，进一步提高系统的高可用性。</p>
<p>哨兵是一个独立的进程，通过发送 PING 命令，让 Redis 服务器返回其运行状态。当哨兵监测到 master 断线之后，会自动将 slave 切换成 master，然后通过<strong>发布订阅模式</strong>通知其他的 slave 修改配置文件，让它们更改主机。</p>
<p>一个哨兵进程对 Redis 服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵对 Redis 服务器进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><img src="/images/redis-sentinel.webp" alt="多哨兵模式"></p>
<p>哨兵模式下，主从服务器的切换过程：</p>
<p>假设主服务器断线，哨兵 1 先检测到这个结果，系统并不会马上进行主从切换，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。</p>
<p>当后面的哨兵也检测到主服务器不可用，并且达到一定数量时，就会认为该服务器是真的不可以用了，这个现象称为<strong>客观下线</strong>。</p>
<p>此时哨兵之间会进行一次投票选出一个哨兵，它会在断线的 master 下所有 slave 中选取一个 slave 作为新 master。切换成功后，向剩余的 slave 节点发送命令，让他们成为新 master 节点的 slave 节点。（原来的 master 会变成 slave）</p>
<p>选取 slave 作为 master 的依据：</p>
<ol>
<li>选择 replica-priority(slave 节点优先级)最高的 slave 节点，如果存在则返回,不存在则继续下一步判断</li>
<li>选择偏移量最大(获得原主机数据最全的)的 slave 节点，如果存在则返回，不存在则继续</li>
<li>选择 runId 最小的 slave 节点(启动最早的节点)</li>
</ol>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>在哨兵模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis 3.0 上加入了 无中心化集群(Cluster) 集群模式，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的内容。</p>
<p>Redis 集群实现了对 Redis 的水平扩容，即启动 N 个 redis 节点，将整个数据库分布存储在这 N 个节点中，每个节点存储总数据的 1&#x2F;N。即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<blockquote>
<p>使用集群时需要在配置文件中做如下配置：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">cluster-enabled yes  # 打开集群模式<br>cluster-config-file nodes-<span class="hljs-number">6379</span>.conf # 设定节点配置文件名<br>cluster-node-timeout <span class="hljs-number">15000</span> # 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换<br></code></pre></td></tr></table></figure>
</blockquote>
<p>集群的工作方式</p>
<p>在 Redis 的每一个节点上都有一个插槽（slot），插槽总的取值范围是：0-16383，插槽的数量平均分布到每个节点。</p>
<p><img src="/images/redis-cluster.png" alt="image-20210710232850359"></p>
<p>当我们的存取的 Key 到达的时候，Redis 会根据 crc16 算法得出一个值，然后对 16384 取余。这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，找到对应的插槽所对应的节点，然后自动跳转到这个对应的节点上进行操作。</p>
<p>为了保证高可用，集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点断线的时候，就会启用从节点。当其它主节点 ping 此主节点时，如果半数以上的主节点与此主节点通信超时，那么认为主节点 A 断线了，此时会进行主从切换。</p>
<p>好处：</p>
<ol>
<li>实现扩容</li>
<li>分摊压力</li>
<li>无中心配置相对简单</li>
</ol>
<p>缺点：</p>
<ol>
<li><strong>多键操作是不被支持的</strong></li>
<li>lua 脚本不被支持</li>
<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至 redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</li>
</ol>
<h2 id="Redis-应用"><a href="#Redis-应用" class="headerlink" title="Redis 应用"></a>Redis 应用</h2><h3 id="整合-springboot"><a href="#整合-springboot" class="headerlink" title="整合 springboot"></a>整合 springboot</h3><ol>
<li><p>在 pom.xml 文件中引入 redis 相关依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>application.properties 配置 redis 配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Redis服务器地址</span><br><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">IP地址</span><br><span class="hljs-comment"># Redis服务器连接端口</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">端口</span><br><span class="hljs-comment"># Redis数据库索引（默认为0）</span><br><span class="hljs-attr">spring.redis.database</span>= <span class="hljs-string">0</span><br><span class="hljs-comment"># 连接超时时间（毫秒）</span><br><span class="hljs-attr">spring.redis.timeout</span>=<span class="hljs-string">1800000</span><br><span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">20</span><br><span class="hljs-comment"># 最大阻塞等待时间(负数表示没限制)</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">-1</span><br><span class="hljs-comment"># 连接池中的最大空闲连接</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">5</span><br><span class="hljs-comment"># 连接池中的最小空闲连接</span><br><span class="hljs-attr">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>添加 redis 配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br>		<span class="hljs-comment">// key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br>		<span class="hljs-comment">// value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>		<span class="hljs-comment">// value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(<br>            Object.class<br>        );<br>		<span class="hljs-comment">// 解决查询缓存转换异常的问题</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br><br>		<span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>            .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>            .serializeKeysWith(<br>            RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)<br>        ).serializeValuesWith(<br>            RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)<br>        ).disableCachingNullValues();<br><br>        <span class="hljs-type">RedisCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试使用：使用<code>redisTemplate.opsForValue()</code>来操作 redis</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/redisTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTestController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 设置值到redis</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;hjh&quot;</span>);<br>        <span class="hljs-comment">// 从redis获取值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="redis-JavaAPI"><a href="#redis-JavaAPI" class="headerlink" title="redis-JavaAPI"></a>redis-JavaAPI</h3><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透：key 对应的数据在数据源中并不存在，那么每次针对此 key 的请求在缓存中都获取不到，接着会去请求数据源，从而可能压垮数据源。比如用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p><img src="/images/redis-cache-chuanTou.png" alt="缓存穿透"></p>
<p>解决方案：</p>
<ol>
<li><strong>对空值缓存</strong>：如果一个查询返回的数据为空（不管 key 是否存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</li>
<li><strong>采用布隆过滤器</strong>：将所有存在的 key 哈希到一个足够大的 bitmaps 中，一个一定不存在的数据会被 这个 bitmaps 拦截掉，从而避免了对底层存储系统的查询压力。<ul>
<li>查询一个 key 时，将 key 映射到 bitmaps 上，只要映射的位置有一个 bit 为 0，说明此 key 肯定不存在。</li>
</ul>
</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿：key 对应的数据存在，但在 redis 中过期，若此时有大量并发请求此 key 的数据，由于 redis 中该 key 已过期，不得不去访问数据源，此时可能会瞬间把数据库压垮。</p>
<p><img src="/images/redis.cache-jiChuan.png" alt="缓存击穿"></p>
<p>解决方案：</p>
<ol>
<li><strong>预先设置热门数据</strong>：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长。</li>
<li><strong>过期前先去获取数据</strong>：在热门数据过期前，先去数据库中获取数据放入缓存中。</li>
<li><strong>使用锁</strong>：缓存失效后重新获取缓存时进行上锁。</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是多个 key 的缓存击穿版本。即缓存雪崩是多个 key 缓存过期的情况，而缓存击穿是某一个 key 缓存过期。</p>
<p>解决方案：</p>
<ol>
<li><strong>构建多级缓存架构</strong>：nginx 缓存 + redis 缓存 +其他缓存</li>
<li><strong>将缓存失效时间分散开</strong>：在原有的失效时间基础上增加一个随机失效时间，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>
</ol>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><strong>场景</strong>：在分布式系统中，需要操作共享资源。</p>
<p>Java 中的锁，只能保证在同一个 JVM 进程内中执行。如果在分布式集群环境下呢，不同的主机要怎么知道这把锁？</p>
<p>实现分布式锁的方式：</p>
<ol>
<li>redis 的方式实现分布式锁。已有线程框架 Redission 实现。</li>
<li>基于 zookeeper</li>
<li>Mysql 的主键或唯一键</li>
</ol>
<hr>
<p>其实 redis 实现分布式锁很简单，就是采用<code>set</code> 命令生成一把锁，然后我们利用这把锁进行操作而已。</p>
<p>生成锁：<code>SET lock_key random_value nx px t</code></p>
<ul>
<li><p>lock_key：锁的名字</p>
</li>
<li><p>random_value：锁的值。最好弄成随机的，例如 uuid，不然会造成锁的误删。</p>
</li>
<li><p>nx：相当于 setnx。只在键不存在时，才对键进行设置操作。</p>
</li>
<li><p>px t：设置过期时间，t 的单位是<strong>毫秒</strong>。</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
问题来了：</p>
</li>
</ul>
<ol>
<li><p>为什么要设置过期时间？<strong>防止锁一直不释放</strong>。</p>
</li>
<li><p>为什么不直接使用 setnx 的方式？<strong>因为 setnx 跟 expire t 是两个操作，并不是一个原子操作，多线程下会出错</strong>。</p>
</li>
<li><p>为什么要锁的值最好要设为 uuid？如果不判断锁的 value 直接解锁的话，当这台服务器卡住了之后，并且锁的过期时间到了，此时这把锁被其他服务器的线程获取，接着这台服务器恢复了，继续操作，操作完释放锁，此时释放的是其他服务器的线程的锁，因为没有对锁的 value 进行判断，所以所有请求使用的锁都是同一把。</p>
</li>
</ol>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    <span class="hljs-comment">// set命令的参数</span><br>    <span class="hljs-type">SetParams</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> SetParams.setParams().nx().px(<span class="hljs-number">3000</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;lock_key&quot;</span>, uuid, params);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;OK&quot;</span>.equals(lock))&#123;<br>        System.out.println(<span class="hljs-string">&quot;获取到了锁，可以进行操作&quot;</span>);<br>        <span class="hljs-comment">// 对锁的value值进行判断。</span><br>        <span class="hljs-keyword">if</span>(uuid.equals(jedis.get(<span class="hljs-string">&quot;lock_key&quot;</span>)))&#123;<br>            System.out.println(<span class="hljs-string">&quot;正在释放锁。。。&quot;</span>);<br>            jedis.del(<span class="hljs-string">&quot;lock_key&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;目前有锁，请等待&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还有一种极端的情况就是，在第 10 行或者删除 key 的过程中（此时 key 还没删掉），电脑卡机了，然后到了过期时间，这把锁被其他线程获取了，接着电脑好了，继续执行删除 key 的操作。此时就会出现删错 key 的情况。虽然这种情况很极端，也很少出现，但是存在。</p>
<p>解决方案是 在 key 没有被主动 del 的情况下，开启一个线程定时的给 key 加过期时间。该方法可以用 lua 脚本实现，&#x3D;&#x3D;redisson 这个框架已经帮我们封装好了，可以直接像 lock 一样直接加锁解锁即可&#x3D;&#x3D;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">redisson.lock();<br><span class="hljs-comment">// 业务逻辑</span><br>redisson.unlock();<br></code></pre></td></tr></table></figure>

      <div class="tags">
          <a href="/tags/Redis/" rel="tag"><i class="ic i-tag"></i> Redis</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2024-04-26 15:55:03" itemprop="dateModified" datetime="2024-04-26T15:55:03+08:00">2024-04-26</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="myHikari 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="myHikari 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="myHikari 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>myHikari <i class="ic i-at"><em>@</em></i>myHikari
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://myhikari.github.io/2023/09/15/Redis/" title="Redis">http://myhikari.github.io/2023/09/15/Redis/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2022/07/06/Zuul-Gateway/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfw2t96j20zk0m8x6p.jpg" title="Zuul-Gateway">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> Spring</span>
  <h3>Zuul-Gateway</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/09/21/Dubbo/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipesng5oej20zk0m87d4.jpg" title="Dubbo">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> Dubbo</span>
  <h3>Dubbo</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">1.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">Redis 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">NoSQL 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-CPU-%E5%8F%8A%E5%86%85%E5%AD%98%E5%8E%8B%E5%8A%9B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">解决 CPU 及内存压力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84-IO-%E5%8E%8B%E5%8A%9B"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">解决数据库的 IO 压力</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.1.2.</span> <span class="toc-text">Redis 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-string"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">字符串 string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8-list"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">列表 list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88-set"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">集合 set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C-hash"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">哈希 hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-zset"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">有序集合 zset</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">新数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmaps"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">Bitmaps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Geospatial"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">Geospatial</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.6.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">1.1.7.</span> <span class="toc-text">发布和订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.1.8.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.8.1.1.</span> <span class="toc-text">快照执行的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%BF%AB%E7%85%A7%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.8.1.2.</span> <span class="toc-text">执行快照的场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.8.2.1.</span> <span class="toc-text">AOF 持久化流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.8.2.2.</span> <span class="toc-text">AOF 持久化策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF-%E9%87%8D%E5%86%99"><span class="toc-number">1.1.8.2.3.</span> <span class="toc-text">AOF 重写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E6%81%A2%E5%A4%8D"><span class="toc-number">1.1.8.2.4.</span> <span class="toc-text">文件损坏恢复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E5%93%AA%E4%B8%AA%E5%A5%BD"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">用哪个好</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.1.9.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">复制原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QA"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">QA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">搭建主从复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.10.</span> <span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.11.</span> <span class="toc-text">集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">Redis 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%90%88-springboot"><span class="toc-number">1.2.1.</span> <span class="toc-text">整合 springboot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-JavaAPI"><span class="toc-number">1.2.2.</span> <span class="toc-text">redis-JavaAPI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.3.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.3.3.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.3.4.</span> <span class="toc-text">分布式锁</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li class="active"><a href="/2023/09/15/Redis/" rel="bookmark" title="Redis">Redis</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="myHikari"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">myHikari</p>
  <div class="description" itemprop="description">myHikari 个人博客</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">15</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">14</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">15</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2022/07/06/Zuul-Gateway/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/09/21/Dubbo/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/ElasticSearch/" title="分类于 ElasticSearch">ElasticSearch</a>
</div>

    <span><a href="/2022/06/12/ElasticSearch/" title="ElasticSearch">ElasticSearch</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/ZookKeeper/" title="分类于 ZookKeeper">ZookKeeper</a>
</div>

    <span><a href="/2022/05/29/ZookKeeper/" title="ZookKeeper">ZookKeeper</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Git/" title="分类于 Git">Git</a>
</div>

    <span><a href="/2021/12/16/Git/" title="Git">Git</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Spring/" title="分类于 Spring">Spring</a>
</div>

    <span><a href="/2022/07/06/Zuul-Gateway/" title="Zuul-Gateway">Zuul-Gateway</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/OpenFeign/" title="分类于 OpenFeign">OpenFeign</a>
</div>

    <span><a href="/2022/05/11/OpenFeign/" title="OpenFeign">OpenFeign</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Redis/" title="分类于 Redis">Redis</a>
</div>

    <span><a href="/2023/09/15/Redis/" title="Redis">Redis</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/docker/" title="分类于 docker">docker</a>
</div>

    <span><a href="/2024/04/25/Docker/" title="Docker">Docker</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Nacos/" title="分类于 Nacos">Nacos</a>
</div>

    <span><a href="/2022/04/28/Nacos/" title="Nacos">Nacos</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a>
</div>

    <span><a href="/2024/04/25/designModel/" title="designModel">designModel</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Spring/" title="分类于 Spring">Spring</a>
</div>

    <span><a href="/2022/01/16/Spring/" title="Spring">Spring</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">myHikari @ Yume Shoka</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/09/15/Redis/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
